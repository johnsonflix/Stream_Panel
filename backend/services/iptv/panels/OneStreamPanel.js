/**
 * OneStreamPanel - 1-Stream Panel Implementation
 *
 * Implements BaseIPTVPanel for 1-Stream panel type.
 * Uses Billing API for management and Player API for streaming.
 */

const axios = require('axios');
const BaseIPTVPanel = require('../BaseIPTVPanel');

class OneStreamPanel extends BaseIPTVPanel {
    constructor(panelConfig, db) {
        super(panelConfig, db);

        // 1-Stream uses API Key + Username authentication
        this.apiKey = panelConfig.credentials?.api_key || null;
        this.username = panelConfig.credentials?.username || null;

        // Rate limiting
        this.minRequestInterval = 1000; // 1 second between requests
    }

    /**
     * Get common headers for API requests
     */
    getHeaders() {
        return {
            'Content-Type': 'application/json',
            'X-Api-Key': this.apiKey,
            'X-Auth-User': this.username,
            'User-Agent': 'SubsApp/1.0'
        };
    }

    /**
     * Test connection to panel by fetching profile
     */
    async testConnection() {
        try {
            await this.authenticate();
            return true;
        } catch (error) {
            console.error(`‚ùå 1-Stream panel ${this.name} connection test failed:`, error.message);
            return false;
        }
    }

    /**
     * Authenticate with 1-Stream panel (test API access)
     */
    async authenticate() {
        try {
            console.log(`üîë Testing 1-Stream panel authentication: ${this.name}`);
            console.log(`   URL: ${this.baseURL}/ext/profile`);
            console.log(`   Headers:`, this.getHeaders());

            const response = await axios({
                method: 'GET',
                url: `${this.baseURL}/ext/profile`,
                headers: this.getHeaders(),
                timeout: 15000
            });

            console.log(`üì• Raw response status: ${response.status}`);
            console.log(`üì• Raw response data:`, JSON.stringify(response.data, null, 2));

            if (response.data && response.data.name !== undefined) {
                console.log(`‚úÖ 1-Stream panel ${this.name} authenticated successfully`);
                console.log(`   Reseller: ${response.data.name}, Credits: ${response.data.credits || 0}`);
                this.authToken = 'authenticated'; // Set flag
                return true;
            }

            console.error(`‚ùå Unexpected response structure. Expected 'name' field but got:`, response.data);
            throw new Error('Invalid response from panel');

        } catch (error) {
            if (error.response) {
                console.error(`‚ùå API Error Response:`, {
                    status: error.response.status,
                    statusText: error.response.statusText,
                    data: error.response.data
                });
            }
            console.error(`‚ùå 1-Stream panel ${this.name} authentication failed:`, error.message);
            await this.updateHealthStatus('error');
            throw error;
        }
    }

    /**
     * Create a new user on the panel
     */
    async createUser(username, password, packageData, bouquetIds, isTrial = false, notes = '') {
        await this.ensureAuthenticated();
        await this.rateLimit();

        try {
            // Check if credentials are provided
            const usernameProvided = username && username.trim() !== '';
            const passwordProvided = password && password.trim() !== '';
            const willAutoGenerateBoth = !usernameProvided && !passwordProvided;

            const payload = {
                package: parseInt(packageData.panel_package_id),
                reseller_notes: notes || ''
            };

            // Add username if provided
            if (usernameProvided) {
                payload.username = username;
                console.log(`üìù Using provided username: ${username}`);
            } else {
                console.log(`üìù Username will be auto-generated by panel`);
            }

            // Add password if provided
            if (passwordProvided) {
                payload.password = password;
                console.log(`üìù Using provided password`);
            } else {
                console.log(`üìù Password will be auto-generated by panel`);
            }

            // Add bouquets if specified
            if (bouquetIds && bouquetIds.length > 0) {
                payload.bouquets = bouquetIds.map(id => parseInt(id));
            }

            // Add unique request ID for idempotency
            payload.rid = `subsapp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            console.log(`üìù Creating user on 1-Stream panel ${this.name}:`, {
                username: username || '(auto-generate)',
                package: payload.package,
                bouquets: payload.bouquets?.length || 0,
                trial: isTrial
            });

            const response = await axios({
                method: 'POST',
                url: `${this.baseURL}/ext/line/create`,
                headers: this.getHeaders(),
                data: payload,
                timeout: 30000
            });

            console.log('üìù Panel API response:', JSON.stringify(response.data, null, 2));

            // Check for errors
            if (response.data.error) {
                throw new Error(`Panel API error: ${response.data.error}`);
            }

            // Handle wrapped response structure: { status: "success", data: { line_id, ... } }
            // or direct response: { line_id, ... }
            const responseData = response.data.data || response.data;
            const lineId = responseData.line_id;
            const expireAt = responseData.expire_at;

            console.log(`üìù Extracted from response - line_id: ${lineId}, expire_at: ${expireAt}`);

            // ALWAYS fetch the created line to get actual credentials from the panel
            // The panel may ignore credentials we send and generate its own (especially passwords)
            console.log(`üîç Fetching actual credentials for line ${lineId} from panel...`);

            // Wait a moment for the line to be indexed
            await new Promise(resolve => setTimeout(resolve, 2000));

            const allLines = await this.getAllUsers(1000, 0);

            // Try to find by line_id first, then by username as fallback
            let createdLine = null;
            if (lineId) {
                createdLine = allLines.find(line => line.line_id === lineId);
            }

            // If not found by lineId, try finding by username (from response or payload)
            if (!createdLine) {
                const createdUsername = responseData.username || payload.username;
                if (createdUsername) {
                    console.log(`üîç Line not found by ID, searching by username: ${createdUsername}`);
                    createdLine = allLines.find(line =>
                        line.username && line.username.toLowerCase() === createdUsername.toLowerCase()
                    );
                }
            }

            // Last resort: find the most recently created line (by ID if numeric, otherwise by list position)
            if (!createdLine && allLines.length > 0) {
                console.log(`üîç Trying to find most recently created line...`);
                // Sort by line_id descending if numeric, or take last item
                const sortedLines = [...allLines].sort((a, b) => {
                    // Try numeric comparison first
                    const aId = parseInt(a.line_id) || 0;
                    const bId = parseInt(b.line_id) || 0;
                    if (aId && bId) return bId - aId;
                    // Otherwise compare as strings
                    return String(b.line_id || '').localeCompare(String(a.line_id || ''));
                });
                createdLine = sortedLines[0];
                console.log(`‚ö†Ô∏è Using most recent line as fallback: ${createdLine?.username}`);
            }

            if (!createdLine) {
                throw new Error('Line created but could not retrieve credentials from panel');
            }

            console.log(`‚úÖ Found line with actual credentials from panel`);
            console.log(`üìù Created line data:`, JSON.stringify(createdLine, null, 2));

            // Parse expiration timestamp - use create response expireAt, fallback to createdLine.expire_at
            let expirationTimestamp = null;
            const effectiveExpireAt = expireAt || createdLine.expire_at;
            if (effectiveExpireAt) {
                expirationTimestamp = Math.floor(new Date(effectiveExpireAt).getTime() / 1000);
                console.log(`üìÖ Parsed expiration: ${effectiveExpireAt} ‚Üí ${expirationTimestamp}`);
            } else {
                console.log(`üìÖ No expiration date (trial or unlimited user)`);
            }

            await this.logActivity(
                null,
                lineId,
                isTrial ? 'create_trial' : 'create_paid',
                packageData.package_id,
                isTrial ? 0 : packageData.credits,
                true,
                null,
                response.data
            );

            // Use createdLine values as primary source (most accurate from panel)
            return {
                username: createdLine.username,
                password: createdLine.password,
                line_id: lineId || createdLine.line_id,
                expiration: expirationTimestamp,
                connections: createdLine.max_connections,
                package_id: packageData.package_id,
                is_trial: isTrial,
                created: true,
                auto_generated: willAutoGenerateBoth,
                full_user_data: createdLine
            };

        } catch (error) {
            console.error(`‚ùå Failed to create user ${username}:`, error.message);

            await this.logActivity(
                null,
                null,
                isTrial ? 'create_trial' : 'create_paid',
                packageData.package_id,
                0,
                false,
                error.message,
                null
            );

            throw error;
        }
    }

    /**
     * Get extension packages for renewal
     * 1-Stream allows selecting ANY package for renewal (not limited like NXT Dash)
     */
    async getExtensionPackages(lineId) {
        await this.ensureAuthenticated();

        try {
            console.log(`üì¶ Fetching available packages for renewal from 1-Stream panel ${this.name}...`);

            const response = await axios({
                method: 'GET',
                url: `${this.baseURL}/ext/packages`,
                headers: this.getHeaders(),
                timeout: 30000
            });

            const packagesData = response.data || [];
            console.log(`‚úÖ Got ${packagesData.length} packages from panel API`);

            // Transform to standardized format
            const packages = packagesData.map(pkg => {
                // Convert hours to days for display
                const durationDays = Math.round(pkg.duration_hours / 24);
                const durationMonths = Math.round(pkg.duration_hours / (24 * 30));

                // Build duration text
                let durationText;
                if (durationDays < 30) {
                    durationText = `${durationDays} day${durationDays !== 1 ? 's' : ''}`;
                } else {
                    durationText = `${durationMonths} month${durationMonths !== 1 ? 's' : ''}`;
                }

                return {
                    id: pkg.id.toString(),
                    name: pkg.name,
                    duration_hours: pkg.duration_hours,
                    duration_text: durationText,
                    connections: pkg.max_connections,
                    credits: pkg.price_credits,
                    package_type: pkg.package_type || 'all',
                    bouquets: pkg.bouquets || []
                };
            });

            return packages;

        } catch (error) {
            console.error(`‚ùå Failed to get extension packages from panel ${this.name}:`, error.message);
            throw error;
        }
    }

    /**
     * Update user's bouquets
     * Used after renewal to apply bouquet sync mode
     */
    async updateUserBouquets(lineId, bouquetIds) {
        await this.ensureAuthenticated();
        await this.rateLimit();

        try {
            const payload = {
                bouquets: bouquetIds.map(id => parseInt(id)),
                rid: `subsapp_bouquet_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
            };

            console.log(`üìù Updating bouquets for user ${lineId} on 1-Stream panel ${this.name}`);
            console.log(`üìù Setting ${bouquetIds.length} bouquets`);

            const response = await axios({
                method: 'POST',
                url: `${this.baseURL}/ext/line/${lineId}/update-advanced`,
                headers: this.getHeaders(),
                data: payload,
                timeout: 30000
            });

            console.log('üìù Panel API response:', JSON.stringify(response.data, null, 2));

            if (response.data.error) {
                throw new Error(`Panel API error: ${response.data.error}`);
            }

            console.log(`‚úÖ Bouquets updated successfully for user ${lineId}`);
            return response.data;

        } catch (error) {
            console.error(`‚ùå Failed to update bouquets for user ${lineId}:`, error.message);
            throw error;
        }
    }

    /**
     * Extend user's subscription (renew)
     * @param {string} lineId - The line ID to renew
     * @param {object} packageData - Package info with panel_package_id
     * @param {array} bouquetIds - Optional bouquet IDs (unused, kept for API compatibility)
     * @param {string} bouquetSyncMode - Optional bouquet sync mode: 'no_change', 'sync_all', 'sync_added', 'sync_removed'
     */
    async extendUser(lineId, packageData, bouquetIds, bouquetSyncMode = 'no_change') {
        await this.ensureAuthenticated();
        await this.rateLimit();

        try {
            const payload = {
                package: parseInt(packageData.panel_package_id),
                rid: `subsapp_renew_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
            };

            console.log(`üìù Extending user ${lineId} on 1-Stream panel ${this.name}`);
            console.log(`üìù Package ID: ${payload.package}, Bouquet Sync Mode: ${bouquetSyncMode}`);

            const response = await axios({
                method: 'POST',
                url: `${this.baseURL}/ext/line/${lineId}/renew`,
                headers: this.getHeaders(),
                data: payload,
                timeout: 30000
            });

            console.log('üìù Panel API response:', JSON.stringify(response.data, null, 2));

            if (response.data.error) {
                throw new Error(`Panel API error: ${response.data.error}`);
            }

            console.log(`‚úÖ User ${lineId} extended successfully`);

            // Handle bouquet sync if not 'no_change'
            if (bouquetSyncMode && bouquetSyncMode !== 'no_change') {
                await this.applyBouquetSyncMode(lineId, packageData.panel_package_id, bouquetSyncMode);
            }

            await this.logActivity(
                null,
                lineId,
                'extend',
                packageData.package_id,
                packageData.credits,
                true,
                null,
                response.data
            );

            return response.data;

        } catch (error) {
            console.error(`‚ùå Failed to extend user ${lineId}:`, error.message);

            await this.logActivity(
                null,
                lineId,
                'extend',
                packageData.package_id,
                0,
                false,
                error.message,
                null
            );

            throw error;
        }
    }

    /**
     * Apply bouquet sync mode after renewal
     * @param {string} lineId - The line ID
     * @param {string} packageId - The package ID to get bouquets from
     * @param {string} syncMode - 'sync_all', 'sync_added', or 'sync_removed'
     */
    async applyBouquetSyncMode(lineId, packageId, syncMode) {
        try {
            console.log(`üîÑ Applying bouquet sync mode '${syncMode}' for user ${lineId}...`);

            // Get current user's bouquets
            const userInfo = await this.getUserInfo(lineId);
            const currentBouquets = userInfo.full_user_data?.bouquets || [];
            console.log(`üìù Current user bouquets: ${currentBouquets.length}`);

            // Get package bouquets
            const packages = await this.getExtensionPackages(lineId);
            const renewPackage = packages.find(p => p.id.toString() === packageId.toString());
            const packageBouquets = renewPackage?.bouquets || [];
            console.log(`üìù Package bouquets: ${packageBouquets.length}`);

            let newBouquets = [];

            switch (syncMode) {
                case 'sync_all':
                    // Remove all current bouquets, add only package bouquets
                    newBouquets = [...packageBouquets];
                    console.log(`üìù Sync All: Setting ${newBouquets.length} bouquets from package`);
                    break;

                case 'sync_added':
                    // Keep current bouquets, add new ones from package
                    const currentSet = new Set(currentBouquets.map(b => parseInt(b)));
                    newBouquets = [...currentBouquets];
                    for (const bouquet of packageBouquets) {
                        if (!currentSet.has(parseInt(bouquet))) {
                            newBouquets.push(bouquet);
                        }
                    }
                    console.log(`üìù Sync Added: ${newBouquets.length} bouquets (added ${newBouquets.length - currentBouquets.length} new)`);
                    break;

                case 'sync_removed':
                    // Remove bouquets not in package (keep manually added ones - we can't distinguish, so just use package bouquets as filter)
                    const packageSet = new Set(packageBouquets.map(b => parseInt(b)));
                    newBouquets = currentBouquets.filter(b => packageSet.has(parseInt(b)));
                    console.log(`üìù Sync Removed: ${newBouquets.length} bouquets (removed ${currentBouquets.length - newBouquets.length})`);
                    break;

                default:
                    console.log(`‚ö†Ô∏è Unknown sync mode '${syncMode}', skipping bouquet update`);
                    return;
            }

            // Update bouquets
            if (JSON.stringify(currentBouquets.sort()) !== JSON.stringify(newBouquets.sort())) {
                await this.updateUserBouquets(lineId, newBouquets);
                console.log(`‚úÖ Bouquets updated successfully`);
            } else {
                console.log(`‚ÑπÔ∏è No bouquet changes needed`);
            }

        } catch (error) {
            console.error(`‚ùå Failed to apply bouquet sync mode:`, error.message);
            // Don't throw - renewal succeeded, bouquet sync is secondary
        }
    }

    /**
     * Delete user from panel (terminate)
     */
    async deleteUser(lineId) {
        await this.ensureAuthenticated();
        await this.rateLimit();

        try {
            console.log(`üìù Deleting user ${lineId} from 1-Stream panel ${this.name}`);
            console.log(`üìù DELETE URL: ${this.baseURL}/ext/line/${lineId}/terminate`);

            const response = await axios({
                method: 'POST',
                url: `${this.baseURL}/ext/line/${lineId}/terminate`,
                headers: this.getHeaders(),
                timeout: 30000
            });

            console.log('üìù Panel API response:', JSON.stringify(response.data, null, 2));

            if (response.data.error) {
                throw new Error(`Panel API error: ${response.data.error}`);
            }

            // Verify deletion by checking if the line still exists
            console.log(`üîç Verifying deletion of line ${lineId}...`);
            await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2s for deletion to propagate

            try {
                const allLines = await this.getAllUsers(1000, 0);
                const stillExists = allLines.find(line => line.line_id === lineId);

                if (stillExists) {
                    console.warn(`‚ö†Ô∏è WARNING: Line ${lineId} still exists on panel after deletion!`);
                    console.warn(`‚ö†Ô∏è Line data:`, JSON.stringify(stillExists, null, 2));
                    throw new Error(`Line ${lineId} still exists on panel after deletion attempt`);
                }

                console.log(`‚úÖ Verified: Line ${lineId} no longer exists on panel`);
            } catch (verifyError) {
                // If we can't verify, log the warning but don't fail the deletion
                if (verifyError.message.includes('still exists')) {
                    throw verifyError; // Re-throw if line still exists
                }
                console.warn(`‚ö†Ô∏è Could not verify deletion (panel may be slow to update):`, verifyError.message);
            }

            console.log(`‚úÖ User ${lineId} deleted successfully`);

            await this.logActivity(
                null,
                lineId,
                'delete',
                null,
                0,
                true,
                null,
                response.data
            );

            return true;

        } catch (error) {
            console.error(`‚ùå Failed to delete user ${lineId}:`, error.message);
            if (error.response) {
                console.error(`‚ùå API Error Response:`, {
                    status: error.response.status,
                    statusText: error.response.statusText,
                    data: error.response.data
                });
            }

            await this.logActivity(
                null,
                lineId,
                'delete',
                null,
                0,
                false,
                error.message,
                null
            );

            throw error;
        }
    }

    /**
     * Get all users from panel
     */
    async getAllUsers(limit = 10000, offset = 0) {
        await this.ensureAuthenticated();

        try {
            console.log(`üìù Fetching users from 1-Stream panel ${this.name} (limit: ${limit}, offset: ${offset})`);

            const response = await axios({
                method: 'GET',
                url: `${this.baseURL}/ext/lines/index`,
                headers: this.getHeaders(),
                params: {
                    page: Math.floor(offset / limit) + 1,
                    per_page: limit
                },
                timeout: 60000
            });

            const users = response.data.data?.items || response.data.data || response.data || [];
            console.log(`‚úÖ Fetched ${users.length} users from panel ${this.name}`);

            return users;

        } catch (error) {
            console.error(`‚ùå Failed to get users from panel ${this.name}:`, error.message);
            throw error;
        }
    }

    /**
     * Find user by username
     */
    async findUserByUsername(username) {
        if (!username) {
            return null;
        }

        try {
            // Use the find endpoint if available (requires username AND password)
            // For now, we'll use getAllUsers and filter
            const allUsers = await this.getAllUsers(10000, 0);
            const user = allUsers.find(u => u.username && u.username.toLowerCase() === username.toLowerCase());
            return user || null;
        } catch (error) {
            console.error(`‚ùå Failed to find user ${username}:`, error.message);
            return null;
        }
    }

    /**
     * Get user info by line ID
     * Used for linking existing IPTV panel users
     */
    async getUserInfo(lineId) {
        if (!lineId) {
            throw new Error('Line ID is required');
        }

        console.log(`üîç Getting user info for line ID ${lineId} from panel ${this.name}...`);

        // Fetch all users and find the one with matching ID
        const allUsers = await this.getAllUsers(10000, 0);
        const user = allUsers.find(u => u.line_id && u.line_id.toString() === lineId.toString());

        if (!user) {
            throw new Error(`User with line ID ${lineId} not found on panel ${this.name}`);
        }

        console.log(`‚úÖ Found user: ${user.username} (Line ID: ${user.line_id})`);

        // Parse expiration date from 1-Stream format (ISO date string) to Unix timestamp
        let expirationTimestamp = null;
        if (user.expire_at) {
            try {
                const expirationDate = new Date(user.expire_at);
                expirationTimestamp = Math.floor(expirationDate.getTime() / 1000);
                console.log(`üìÖ Parsed expiration: ${user.expire_at} ‚Üí ${expirationTimestamp} (${expirationDate.toISOString()})`);
            } catch (error) {
                console.error('‚ùå Failed to parse expiration date:', error);
            }
        }

        // Build M3U URL with panel's base M3U URL if available
        let m3uUrl = null;
        if (this.panelConfig && this.panelConfig.m3u_url) {
            try {
                const url = new URL(this.panelConfig.m3u_url);
                url.searchParams.set('username', user.username);
                url.searchParams.set('password', user.password);
                m3uUrl = url.toString();
                console.log(`‚úÖ Built M3U URL with user credentials`);
            } catch (error) {
                console.error('‚ùå Failed to build M3U URL:', error.message);
            }
        }

        // Return user information in expected format
        return {
            line_id: user.line_id,
            username: user.username,
            password: user.password,
            expiration: expirationTimestamp,
            expiry_date: user.expire_at,
            connections: user.max_connections || null,
            max_connections: user.max_connections || null,
            active_connections: user.active_connections || 0,
            status: user.status || 'unknown',
            m3u_url: m3uUrl
        };
    }

    /**
     * Sync packages from panel
     */
    async syncPackages() {
        await this.ensureAuthenticated();

        try {
            console.log(`üì¶ Syncing packages from 1-Stream panel ${this.name}...`);

            const response = await axios({
                method: 'GET',
                url: `${this.baseURL}/ext/packages`,
                headers: this.getHeaders(),
                timeout: 30000
            });

            const packagesData = response.data || [];
            console.log(`‚úÖ Got ${packagesData.length} packages from panel API`);

            const packages = [];

            for (const pkg of packagesData) {
                // Determine if it's a trial based on description or price
                const isTrial = pkg.description && pkg.description.toLowerCase().includes('[trial]');

                // Convert duration from hours to months
                const durationMonths = Math.round(pkg.duration_hours / (24 * 30));

                packages.push({
                    panel_id: this.id,
                    package_id: pkg.id.toString(),
                    name: pkg.name,
                    connections: pkg.max_connections,
                    duration_months: durationMonths,
                    credits: pkg.price_credits,
                    package_type: isTrial ? 'trial' : 'basic'
                });
            }

            console.log(`‚úÖ Synced ${packages.length} packages from panel ${this.name}`);

            // Upsert to database
            for (const pkg of packages) {
                await this.db.query(`
                    INSERT INTO iptv_packages
                    (iptv_panel_id, package_id, name, connections, duration_months, credits, package_type, synced_at)
                    VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now'))
                    ON CONFLICT (iptv_panel_id, package_id) DO UPDATE SET
                    name = excluded.name,
                    connections = excluded.connections,
                    duration_months = excluded.duration_months,
                    credits = excluded.credits,
                    package_type = excluded.package_type,
                    synced_at = datetime('now')
                `, [this.id, pkg.package_id, pkg.name, pkg.connections, pkg.duration_months, pkg.credits, pkg.package_type]);
            }

            await this.updateHealthStatus('online');
            return packages;

        } catch (error) {
            console.error(`‚ùå Failed to sync packages from panel ${this.name}:`, error.message);
            await this.updateHealthStatus('error');
            throw error;
        }
    }

    /**
     * Sync bouquets from panel
     * NOTE: 1-Stream doesn't have a separate /ext/bouquets endpoint.
     * Bouquets are embedded in the packages response, so we extract them from there.
     * If a bouquet_line_id is configured, we fetch bouquet names from the line edit page.
     */
    async syncBouquets() {
        await this.ensureAuthenticated();

        try {
            console.log(`üîÑ Syncing bouquets from 1-Stream panel ${this.name}...`);
            console.log(`üìù Note: 1-Stream embeds bouquets in packages, extracting from /ext/packages`);

            // Fetch packages which contain bouquet IDs
            const response = await axios({
                method: 'GET',
                url: `${this.baseURL}/ext/packages`,
                headers: this.getHeaders(),
                timeout: 30000
            });

            const packagesData = response.data || [];
            console.log(`‚úÖ Got ${packagesData.length} packages from panel API`);

            // Extract unique bouquet IDs from all packages
            const bouquetIdsSet = new Set();
            packagesData.forEach(pkg => {
                if (pkg.bouquets && Array.isArray(pkg.bouquets)) {
                    pkg.bouquets.forEach(bouquetId => bouquetIdsSet.add(bouquetId));
                }
            });

            const bouquetIds = Array.from(bouquetIdsSet);
            console.log(`‚úÖ Found ${bouquetIds.length} unique bouquet IDs across all packages`);

            if (bouquetIds.length === 0) {
                console.warn('‚ö†Ô∏è No bouquets found in packages data');
                await this.updateHealthStatus('online');
                return [];
            }

            // Try to fetch bouquet names from a line edit page if bouquet_line_id is configured
            let bouquetNames = {};
            const bouquetLineId = this.credentials?.bouquet_line_id;

            if (bouquetLineId) {
                console.log(`üìù Fetching bouquet names from line ${bouquetLineId}...`);
                bouquetNames = await this.fetchBouquetNamesFromLineEdit(bouquetLineId);
                console.log(`‚úÖ Got ${Object.keys(bouquetNames).length} bouquet names from line edit page`);
            } else {
                console.log(`‚ö†Ô∏è No bouquet_line_id configured - bouquets will use ID-only names`);
                console.log(`üí° Configure a "Bouquet Names Line ID" in panel settings to get bouquet names`);
            }

            let insertedCount = 0;

            // Insert bouquets to database with names if available
            for (const bouquetId of bouquetIds) {
                try {
                    const bouquetName = bouquetNames[bouquetId] || `Bouquet ${bouquetId}`;

                    await this.db.query(`
                        INSERT INTO iptv_bouquets
                        (iptv_panel_id, bouquet_id, name, category, synced_at)
                        VALUES (?, ?, ?, ?, datetime('now'))
                        ON CONFLICT (iptv_panel_id, bouquet_id) DO UPDATE SET
                        name = excluded.name,
                        synced_at = datetime('now')
                    `, [this.id, bouquetId.toString(), bouquetName, null]);

                    insertedCount++;

                    if (insertedCount % 20 === 0) {
                        console.log(`üìù Inserted ${insertedCount}/${bouquetIds.length} bouquets...`);
                    }
                } catch (insertError) {
                    console.error(`‚ùå Failed to insert bouquet ${bouquetId}:`, insertError.message);
                }
            }

            console.log(`‚úÖ Successfully synced ${insertedCount} bouquets from panel ${this.name}`);

            await this.updateHealthStatus('online');

            return bouquetIds.map(id => ({
                id: id,
                bouquet_name: bouquetNames[id] || `Bouquet ${id}`,
                category: null
            }));

        } catch (error) {
            console.error(`‚ùå Failed to sync bouquets from panel ${this.name}:`, error.message);
            await this.updateHealthStatus('error');
            throw error;
        }
    }

    /**
     * Fetch bouquet names from API endpoints
     * First tries /ext/bouquets, then falls back to getting bouquet names from line data
     * @param {string} lineId - The line ID to fetch (used as fallback to get bouquet names)
     * @returns {Object} - Map of bouquet ID to name
     */
    async fetchBouquetNamesFromLineEdit(lineId) {
        try {
            // First, try the /ext/bouquets endpoint directly
            console.log(`üîç Trying /ext/bouquets endpoint...`);
            try {
                const bouquetsResponse = await axios({
                    method: 'GET',
                    url: `${this.baseURL}/ext/bouquets`,
                    headers: this.getHeaders(),
                    timeout: 30000
                });

                const bouquetsData = bouquetsResponse.data;
                console.log(`üìù /ext/bouquets response type: ${typeof bouquetsData}`);

                if (Array.isArray(bouquetsData) && bouquetsData.length > 0) {
                    const bouquetNames = {};
                    bouquetsData.forEach(bouquet => {
                        if (bouquet.id && bouquet.name) {
                            bouquetNames[bouquet.id.toString()] = bouquet.name;
                        } else if (bouquet.bouquet_id && bouquet.bouquet_name) {
                            bouquetNames[bouquet.bouquet_id.toString()] = bouquet.bouquet_name;
                        }
                    });

                    if (Object.keys(bouquetNames).length > 0) {
                        console.log(`‚úÖ Got ${Object.keys(bouquetNames).length} bouquet names from /ext/bouquets`);
                        const examples = Object.entries(bouquetNames).slice(0, 3);
                        examples.forEach(([id, name]) => {
                            console.log(`   üìù Bouquet ${id}: ${name}`);
                        });
                        return bouquetNames;
                    }
                }
                console.log(`üìù /ext/bouquets returned: ${JSON.stringify(bouquetsData).substring(0, 200)}`);
            } catch (bouquetError) {
                console.log(`‚ö†Ô∏è /ext/bouquets endpoint not available: ${bouquetError.message}`);
            }

            // Second, try getting line details which might include bouquet names
            console.log(`üîç Trying /ext/line/${lineId} endpoint...`);
            try {
                const lineResponse = await axios({
                    method: 'GET',
                    url: `${this.baseURL}/ext/line/${lineId}`,
                    headers: this.getHeaders(),
                    timeout: 30000
                });

                const lineData = lineResponse.data;
                console.log(`üìù /ext/line/${lineId} response keys: ${Object.keys(lineData || {}).join(', ')}`);

                // Check if bouquets have names in the response
                if (lineData.bouquets && Array.isArray(lineData.bouquets)) {
                    const bouquetNames = {};
                    lineData.bouquets.forEach(bouquet => {
                        if (typeof bouquet === 'object' && bouquet.id && bouquet.name) {
                            bouquetNames[bouquet.id.toString()] = bouquet.name;
                        }
                    });

                    if (Object.keys(bouquetNames).length > 0) {
                        console.log(`‚úÖ Got ${Object.keys(bouquetNames).length} bouquet names from line data`);
                        return bouquetNames;
                    }
                }
                console.log(`üìù Line data preview: ${JSON.stringify(lineData).substring(0, 500)}`);
            } catch (lineError) {
                console.log(`‚ö†Ô∏è /ext/line/${lineId} endpoint not available: ${lineError.message}`);
            }

            // Third, try browser session auth if web credentials are available
            const webUsername = this.credentials?.web_username;
            const webPassword = this.credentials?.web_password;

            if (webUsername && webPassword && lineId) {
                console.log(`üîç Trying browser session auth with web credentials...`);
                try {
                    const bouquetNames = await this.fetchBouquetNamesViaWebSession(lineId, webUsername, webPassword);
                    if (Object.keys(bouquetNames).length > 0) {
                        return bouquetNames;
                    }
                } catch (webError) {
                    console.log(`‚ö†Ô∏è Browser session auth failed: ${webError.message}`);
                }
            } else if (!webUsername || !webPassword) {
                console.log(`‚ö†Ô∏è Web credentials not configured - cannot use browser session auth`);
            }

            console.log(`‚ö†Ô∏è Could not fetch bouquet names from API - bouquets will use ID-only names`);
            return {};

        } catch (error) {
            console.error(`‚ùå Failed to fetch bouquet names:`, error.message);
            return {};
        }
    }

    /**
     * Fetch bouquet names via web browser session authentication
     * This logs in to the panel's web interface and scrapes bouquet names from the line edit page
     * @param {string} lineId - The line ID to fetch
     * @param {string} username - Web login username
     * @param {string} password - Web login password
     * @returns {Object} - Map of bouquet ID to name
     */
    async fetchBouquetNamesViaWebSession(lineId, username, password) {
        const tough = require('tough-cookie');
        const { wrapper } = require('axios-cookiejar-support');

        // Create a cookie jar for session management
        const jar = new tough.CookieJar();
        const client = wrapper(axios.create({ jar, withCredentials: true }));

        try {
            // Step 1: Get login page to get CSRF token
            console.log(`   üìù Getting login page for CSRF token...`);
            const loginPageResponse = await client.get(`${this.baseURL}/login`, {
                timeout: 30000,
                headers: {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                    'Accept-Language': 'en-US,en;q=0.5'
                }
            });

            // Extract CSRF token from the login page
            const loginHtml = loginPageResponse.data;
            const csrfMatch = loginHtml.match(/name="_token"\s+value="([^"]+)"/i) ||
                              loginHtml.match(/name="csrf_token"\s+value="([^"]+)"/i) ||
                              loginHtml.match(/name="_csrf"\s+value="([^"]+)"/i) ||
                              loginHtml.match(/<meta[^>]*name="csrf-token"[^>]*content="([^"]+)"/i);

            const csrfToken = csrfMatch ? csrfMatch[1] : null;
            console.log(`   üìù CSRF token: ${csrfToken ? 'found' : 'not found'}`);

            // Detect the login form field names (could be username/email)
            const usernameFieldMatch = loginHtml.match(/name="(username|email|login)"/i);
            const usernameField = usernameFieldMatch ? usernameFieldMatch[1] : 'username';
            console.log(`   üìù Login field detected: ${usernameField}`);

            // Step 2: Submit login form
            console.log(`   üìù Logging in as ${username}...`);
            const loginData = new URLSearchParams();
            loginData.append(usernameField, username);
            loginData.append('password', password);
            loginData.append('remember', 'on'); // Add remember me to get persistent session
            if (csrfToken) {
                loginData.append('_token', csrfToken);
            }

            const loginResponse = await client.post(`${this.baseURL}/login`, loginData.toString(), {
                timeout: 30000,
                headers: {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                    'Origin': this.baseURL,
                    'Referer': `${this.baseURL}/login`
                },
                maxRedirects: 5,
                validateStatus: (status) => status < 400 || status === 302
            });

            console.log(`   üìù Login response status: ${loginResponse.status}`);

            // Initialize bouquet names map
            const bouquetNames = {};

            // Step 3: First try with X-Inertia header to get JSON data directly
            console.log(`   üìù Fetching line edit page /lines/${lineId}/edit with Inertia header...`);
            try {
                const inertiaResponse = await client.get(`${this.baseURL}/lines/${lineId}/edit`, {
                    timeout: 30000,
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                        'Accept': 'text/html, application/xhtml+xml',
                        'X-Inertia': 'true',
                        'X-Inertia-Version': '',
                        'X-Requested-With': 'XMLHttpRequest',
                        'Referer': `${this.baseURL}/lines`
                    }
                });

                const inertiaData = inertiaResponse.data;
                console.log(`   üìù Inertia response type: ${typeof inertiaData}`);

                if (typeof inertiaData === 'object' && inertiaData.props) {
                    console.log(`   üìù Got Inertia JSON response, props keys: ${Object.keys(inertiaData.props || {}).join(', ')}`);
                    const props = inertiaData.props;

                    // Try different possible locations for bouquet data
                    const possibleBouquetSources = [
                        props.bouquets,
                        props.allBouquets,
                        props.available_bouquets,
                        props.line?.bouquets,
                        props.data?.bouquets
                    ];

                    for (const source of possibleBouquetSources) {
                        if (Array.isArray(source) && source.length > 0) {
                            source.forEach(b => {
                                const id = b.id || b.bouquet_id;
                                const name = b.name || b.bouquet_name || b.title;
                                if (id && name && !bouquetNames[id.toString()]) {
                                    bouquetNames[id.toString()] = name;
                                }
                            });
                            if (Object.keys(bouquetNames).length > 0) {
                                console.log(`   ‚úÖ Found ${Object.keys(bouquetNames).length} bouquets in Inertia JSON response`);
                                return bouquetNames;
                            }
                        }
                    }
                    console.log(`   üìù Inertia props preview: ${JSON.stringify(props).substring(0, 500)}`);
                }
            } catch (inertiaError) {
                console.log(`   üìù Inertia request failed: ${inertiaError.message}`);
            }

            // Step 4: Fallback - fetch as regular HTML
            console.log(`   üìù Fetching line edit page /lines/${lineId}/edit as HTML...`);
            const editPageResponse = await client.get(`${this.baseURL}/lines/${lineId}/edit`, {
                timeout: 30000,
                headers: {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                    'Referer': `${this.baseURL}/lines`
                }
            });

            const editHtml = editPageResponse.data;
            console.log(`   üìù Edit page size: ${editHtml.length} chars`);

            // Step 5: Parse bouquet names from HTML

            // This is an Inertia.js app - data is in the data-page attribute
            // Look for: <div id="app" data-page='{"props":{"bouquets":[...]}}'>
            const dataPageMatch = editHtml.match(/data-page=['"]([\s\S]*?)['"]\s*>/i) ||
                                  editHtml.match(/data-page='([^']+)'/i) ||
                                  editHtml.match(/data-page="([^"]+)"/i);

            if (dataPageMatch) {
                try {
                    // Decode HTML entities
                    let pageData = dataPageMatch[1]
                        .replace(/&quot;/g, '"')
                        .replace(/&amp;/g, '&')
                        .replace(/&lt;/g, '<')
                        .replace(/&gt;/g, '>')
                        .replace(/&#039;/g, "'");

                    const inertiaData = JSON.parse(pageData);
                    console.log(`   üìù Found Inertia data, props keys: ${Object.keys(inertiaData.props || {}).join(', ')}`);

                    // Look for bouquets in the props
                    const props = inertiaData.props || {};

                    // Try different possible locations for bouquet data
                    const possibleBouquetSources = [
                        props.bouquets,
                        props.allBouquets,
                        props.available_bouquets,
                        props.line?.bouquets,
                        props.data?.bouquets
                    ];

                    for (const source of possibleBouquetSources) {
                        if (Array.isArray(source) && source.length > 0) {
                            source.forEach(b => {
                                const id = b.id || b.bouquet_id;
                                const name = b.name || b.bouquet_name || b.title;
                                if (id && name && !bouquetNames[id.toString()]) {
                                    bouquetNames[id.toString()] = name;
                                }
                            });
                            if (Object.keys(bouquetNames).length > 0) {
                                console.log(`   ‚úÖ Found bouquets in Inertia props`);
                                break;
                            }
                        }
                    }

                    // If no bouquets array found, log available props for debugging
                    if (Object.keys(bouquetNames).length === 0) {
                        console.log(`   üìù Available props: ${JSON.stringify(Object.keys(props))}`);
                        // Log first 500 chars of props for debugging
                        console.log(`   üìù Props preview: ${JSON.stringify(props).substring(0, 500)}`);
                    }
                } catch (e) {
                    console.log(`   ‚ö†Ô∏è Failed to parse Inertia data: ${e.message}`);
                }
            } else {
                console.log(`   üìù No Inertia data-page attribute found`);
            }

            // Fallback: Look for bouquet checkboxes/options with names in traditional HTML
            if (Object.keys(bouquetNames).length === 0) {
                const bouquetPatterns = [
                    /name="bouquets\[\]"[^>]*value="(\d+)"[^>]*>\s*([^<]+)/gi,
                    /<option[^>]*value="(\d+)"[^>]*>([^<]+)<\/option>/gi,
                    /<label[^>]*>\s*<input[^>]*value="(\d+)"[^>]*>\s*([^<]+)<\/label>/gi,
                    /value="(\d+)"[^>]*>\s*<[^>]*>([^<]+)</gi
                ];

                for (const pattern of bouquetPatterns) {
                    let match;
                    while ((match = pattern.exec(editHtml)) !== null) {
                        const id = match[1];
                        const name = match[2].trim();
                        if (id && name && !bouquetNames[id]) {
                            bouquetNames[id] = name;
                        }
                    }
                }
            }

            if (Object.keys(bouquetNames).length > 0) {
                console.log(`‚úÖ Got ${Object.keys(bouquetNames).length} bouquet names via web session`);
                const examples = Object.entries(bouquetNames).slice(0, 3);
                examples.forEach(([id, name]) => {
                    console.log(`   üìù Bouquet ${id}: ${name}`);
                });
            } else {
                console.log(`‚ö†Ô∏è No bouquet names found in edit page HTML`);
                // Log a portion of the HTML for debugging
                console.log(`   üìù HTML snippet: ${editHtml.substring(0, 500)}`);
            }

            return bouquetNames;

        } catch (error) {
            console.error(`‚ùå Web session auth failed:`, error.message);
            throw error;
        }
    }

    /**
     * Get credit balance
     */
    async getCreditBalance() {
        await this.ensureAuthenticated();

        try {
            const response = await axios({
                method: 'GET',
                url: `${this.baseURL}/ext/profile`,
                headers: this.getHeaders(),
                timeout: 15000
            });

            const credits = Math.round(parseFloat(response.data.credits) || 0);
            console.log(`‚úÖ Panel ${this.name} credit balance: ${credits}`);

            // Update in database
            await this.db.query(`
                UPDATE iptv_panels
                SET current_credit_balance = ?
                WHERE id = ?
            `, [credits, this.id]);

            return credits;

        } catch (error) {
            console.error(`‚ùå Failed to get credit balance from panel ${this.name}:`, error.message);
            throw error;
        }
    }

    /**
     * Get live connections with user data
     */
    async getLiveConnections() {
        await this.ensureAuthenticated();

        try {
            console.log(`üîç Fetching live connections from 1-Stream panel ${this.name}...`);

            // Fetch connections and users in parallel for efficiency
            const [connectionsResponse, usersResponse] = await Promise.all([
                axios({
                    method: 'GET',
                    url: `${this.baseURL}/ext/live_connections/index`,
                    headers: this.getHeaders(),
                    params: {
                        type: 'online',
                        show_restreamer: 0,
                        per_page: 1000
                    },
                    timeout: 30000
                }),
                axios({
                    method: 'GET',
                    url: `${this.baseURL}/ext/lines/index`,
                    headers: this.getHeaders(),
                    params: {
                        per_page: 10000
                    },
                    timeout: 60000
                }).catch(err => {
                    console.warn(`‚ö†Ô∏è Failed to fetch users for connection enrichment: ${err.message}`);
                    return { data: [] };
                })
            ]);

            const connections = connectionsResponse.data || [];
            const users = usersResponse.data?.data?.items || usersResponse.data?.data || usersResponse.data || [];

            console.log(`‚úÖ Got ${connections.length} active connections and ${users.length} users for enrichment`);

            // Build user lookup map for maxConnections and expireDate
            const userLookup = {};
            users.forEach(user => {
                if (user.username) {
                    userLookup[user.username.toLowerCase()] = {
                        maxConnections: user.max_connections || 0,
                        expireDate: user.expire_at || null,
                        status: user.status || 'active'
                    };
                }
            });

            // Group connections by username
            const userConnections = {};
            connections.forEach(conn => {
                const username = conn.username;
                const usernameLower = username?.toLowerCase();
                const userData = userLookup[usernameLower] || { maxConnections: 0, expireDate: null, status: 'active' };

                if (!userConnections[username]) {
                    userConnections[username] = {
                        username: username,
                        connections: [],
                        activeConnections: 0,
                        maxConnections: userData.maxConnections,
                        expireDate: userData.expireDate,
                        status: userData.status,
                        panel_id: this.id,
                        panel_name: this.name
                    };
                }

                userConnections[username].activeConnections++;
                userConnections[username].connections.push({
                    streamName: conn.stream || 'Unknown',
                    ip: conn.line_ip || 'Unknown',
                    userAgent: conn.user_agent || 'Unknown',
                    dateStart: conn.created_at_unix ? new Date(conn.created_at_unix * 1000).toISOString() : null
                });
            });

            const liveViewers = Object.values(userConnections);

            console.log(`‚úÖ Panel ${this.name} has ${liveViewers.length} users with active streams`);

            return liveViewers;

        } catch (error) {
            console.error(`‚ùå Failed to get live connections from panel ${this.name}:`, error.message);
            return [];
        }
    }

    /**
     * Get dashboard statistics
     */
    async getDashboardStatistics() {
        try {
            console.log(`üìä Gathering dashboard statistics for 1-Stream panel ${this.name}...`);

            // Fetch panel data to check for M3U URL and get cached logos
            const [panelData] = await this.db.query(`
                SELECT m3u_url, m3u_channel_count, m3u_movie_count, m3u_series_count, m3u_last_sync, m3u_channel_logos
                FROM iptv_panels
                WHERE id = ?
            `, [this.id]);

            // Fetch all data in parallel
            const [creditsResult, usersResult, liveResult] = await Promise.allSettled([
                this.getCreditBalance(),
                this.getAllUsers(10000, 0),
                this.getLiveConnections()
            ]);

            // Extract results
            const credits = creditsResult.status === 'fulfilled' ? creditsResult.value : 0;
            const users = usersResult.status === 'fulfilled' ? usersResult.value : [];
            let liveViewers = liveResult.status === 'fulfilled' ? liveResult.value : [];

            // Parse channel logos if available and enrich live connections
            if (panelData?.m3u_channel_logos && liveViewers.length > 0) {
                try {
                    const channelLogos = JSON.parse(panelData.m3u_channel_logos);
                    const { findLogoForStream } = require('../../../utils/m3u-parser');

                    // Enrich each viewer's connections with logo info
                    liveViewers = liveViewers.map(viewer => ({
                        ...viewer,
                        connections: viewer.connections.map(conn => {
                            const logoInfo = findLogoForStream(conn.streamName, channelLogos);
                            return {
                                ...conn,
                                logo: logoInfo?.logo || null,
                                category: logoInfo?.group || null
                            };
                        })
                    }));

                    console.log(`üñºÔ∏è Enriched ${liveViewers.length} live viewers with channel logos`);
                } catch (parseError) {
                    console.warn(`‚ö†Ô∏è Failed to parse channel logos for panel ${this.name}:`, parseError.message);
                }
            }

            // Determine content counts
            let liveChannels = 0;
            let vodMovies = 0;
            let vodSeries = 0;
            let contentStatus = 'configured';

            // Check if M3U URL is configured
            if (panelData && panelData.m3u_url) {
                liveChannels = panelData.m3u_channel_count || 0;
                vodMovies = panelData.m3u_movie_count || 0;
                vodSeries = panelData.m3u_series_count || 0;
                contentStatus = 'configured';
                console.log(`‚úÖ Using M3U counts for panel ${this.name} (last sync: ${panelData.m3u_last_sync || 'never'})`);
            } else {
                contentStatus = 'needs_configured';
                console.log(`‚ö†Ô∏è Panel ${this.name} has no M3U URL configured`);
            }

            // Count active users (not expired)
            const now = new Date();
            const activeUsers = users.filter(user => {
                if (!user.expire_at) return true; // Unlimited
                const expireDate = new Date(user.expire_at);
                return expireDate > now;
            }).length;

            const stats = {
                panel_id: this.id,
                panel_name: this.name,
                panel_type: this.panelType,
                credits: credits,
                content: {
                    liveChannels: liveChannels,
                    vodMovies: vodMovies,
                    vodSeries: vodSeries,
                    status: contentStatus,
                    m3u_url: panelData?.m3u_url || null,
                    m3u_last_sync: panelData?.m3u_last_sync || null
                },
                users: {
                    total: users.length,
                    active: activeUsers,
                    liveNow: liveViewers.length
                },
                liveViewers: liveViewers,
                lastUpdate: new Date().toISOString()
            };

            console.log(`‚úÖ Dashboard statistics for ${this.name}:`, {
                credits: stats.credits,
                content: stats.content,
                users: stats.users,
                liveViewers: stats.liveViewers.length
            });

            // Update database with cached statistics
            try {
                await this.db.query(`
                    UPDATE iptv_panels
                    SET
                        user_count = ?,
                        active_user_count = ?,
                        live_connection_count = ?,
                        current_credit_balance = ?,
                        last_stats_update = ?
                    WHERE id = ?
                `, [
                    users.length,
                    activeUsers,
                    liveViewers.length,
                    credits,
                    new Date().toISOString(),
                    this.id
                ]);
                console.log(`üíæ Cached statistics saved to database for panel ${this.name}`);
            } catch (dbError) {
                console.error(`‚ö†Ô∏è Failed to cache statistics in database for panel ${this.name}:`, dbError.message);
            }

            return stats;

        } catch (error) {
            console.error(`‚ùå Failed to get dashboard statistics from panel ${this.name}:`, error.message);
            throw error;
        }
    }

    /**
     * Get active streams (alias for getLiveConnections for compatibility)
     */
    async getActiveStreams() {
        return await this.getLiveConnections();
    }

    /**
     * Sync M3U playlist and update content counts
     */
    async syncM3UPlaylist() {
        try {
            // Get M3U URL from database
            const [panelData] = await this.db.query(`
                SELECT m3u_url FROM iptv_panels WHERE id = ?
            `, [this.id]);

            if (!panelData || !panelData.m3u_url) {
                throw new Error('No M3U URL configured for this panel');
            }

            console.log(`üîÑ Syncing M3U playlist for panel ${this.name}...`);

            // Parse the M3U playlist (with logo extraction enabled)
            const { parseM3UPlaylist } = require('../../../utils/m3u-parser');
            const result = await parseM3UPlaylist(panelData.m3u_url, true);

            // Serialize channel logos to JSON for storage
            const logosJson = result.channelLogos ? JSON.stringify(result.channelLogos) : null;
            const logoCount = result.channelLogos ? Object.keys(result.channelLogos).length : 0;

            // Update database with counts and logos
            await this.db.query(`
                UPDATE iptv_panels
                SET m3u_channel_count = ?,
                    m3u_movie_count = ?,
                    m3u_series_count = ?,
                    m3u_channel_logos = ?,
                    m3u_last_sync = datetime('now')
                WHERE id = ?
            `, [result.liveChannels, result.vodMovies, result.vodSeries, logosJson, this.id]);

            console.log(`‚úÖ M3U playlist synced for panel ${this.name}:`);
            console.log(`   - Live channels: ${result.liveChannels}`);
            console.log(`   - VOD movies: ${result.vodMovies}`);
            console.log(`   - VOD series: ${result.vodSeries}`);
            console.log(`   - Channel logos cached: ${logoCount}`);

            return {
                success: true,
                counts: {
                    liveChannels: result.liveChannels,
                    vodMovies: result.vodMovies,
                    vodSeries: result.vodSeries,
                    logosCached: logoCount
                },
                lastSync: new Date().toISOString()
            };

        } catch (error) {
            console.error(`‚ùå Failed to sync M3U playlist for panel ${this.name}:`, error.message);
            throw error;
        }
    }
}

module.exports = OneStreamPanel;
