/**
 * IPTVServiceManager - Multi-Panel IPTV Management
 *
 * Factory pattern for managing multiple IPTV panels of different types.
 * Dynamically loads panels from database and instantiates the correct panel class.
 */

const NXTDashPanel = require('./panels/NXTDashPanel');
const XUIOnePanel = require('./panels/XUIOnePanel');
const OneStreamPanel = require('./panels/OneStreamPanel');
const XtreamUIPanel = require('./panels/XtreamUIPanel');
const MidnightStreamerPanel = require('./panels/MidnightStreamerPanel');
const XMOTTPanelPanel = require('./panels/XMOTTPanelPanel');

class IPTVServiceManager {
    constructor(db) {
        this.db = db;
        this.panels = new Map(); // panel_id -> panel instance
        this.initialized = false;
    }

    /**
     * Initialize service - load all active panels from database
     */
    async initialize() {
        try {
            console.log('ðŸ“¡ Initializing IPTV Service Manager...');

            await this.loadPanels();

            this.initialized = true;
            console.log(`âœ… IPTV Service Manager initialized with ${this.panels.size} panels`);

            return true;

        } catch (error) {
            console.error('âŒ Failed to initialize IPTV Service Manager:', error);
            throw error;
        }
    }

    /**
     * Load all active panels from database and instantiate panel objects
     */
    async loadPanels() {
        try {
            const panelConfigs = await this.db.query(`
                SELECT * FROM iptv_panels
                WHERE is_active = TRUE
                ORDER BY name
            `);

            this.panels.clear();

            for (const config of panelConfigs) {
                try {
                    // Parse JSON fields
                    config.credentials = JSON.parse(config.credentials);
                    config.panel_settings = config.panel_settings ? JSON.parse(config.panel_settings) : {};
                    config.session_data = config.session_data ? JSON.parse(config.session_data) : {};

                    // Instantiate the correct panel class based on panel_type
                    const panel = this.createPanelInstance(config);

                    this.panels.set(config.id, panel);

                    console.log(`âœ… Loaded ${config.panel_type} panel: ${config.name} (ID: ${config.id})`);

                } catch (error) {
                    console.error(`âŒ Failed to load panel ${config.name}:`, error.message);
                }
            }

            console.log(`âœ… Loaded ${this.panels.size} IPTV panels from database`);

        } catch (error) {
            console.error('âŒ Failed to load IPTV panels:', error);
            throw error;
        }
    }

    /**
     * Factory method to create panel instance based on panel type
     */
    createPanelInstance(config) {
        switch (config.panel_type) {
            case 'nxt_dash':
                return new NXTDashPanel(config, this.db);

            case 'xui_one':
                return new XUIOnePanel(config, this.db);

            case 'one_stream':
                return new OneStreamPanel(config, this.db);

            case 'xtream_ui':
                return new XtreamUIPanel(config, this.db);

            case 'midnight_streamer':
                return new MidnightStreamerPanel(config, this.db);

            case 'xm_ottpanel':
                return new XMOTTPanelPanel(config, this.db);

            default:
                throw new Error(`Unknown panel type: ${config.panel_type}`);
        }
    }

    /**
     * Get panel instance by ID
     */
    getPanel(panelId) {
        const panel = this.panels.get(panelId);
        if (!panel) {
            throw new Error(`Panel ${panelId} not found or not active`);
        }
        return panel;
    }

    /**
     * Get all panel instances
     */
    getAllPanels() {
        return Array.from(this.panels.values());
    }

    /**
     * Get panel info for all panels
     */
    getAllPanelInfo() {
        const panelList = [];
        for (const [panelId, panel] of this.panels) {
            panelList.push(panel.getPanelInfo());
        }
        return panelList;
    }

    /**
     * Create user on specific panel
     */
    async createUserOnPanel(panelId, username, password, packageData, bouquetIds, isTrial = false, notes = '') {
        const panel = this.getPanel(panelId);

        console.log(`ðŸ“¡ Creating user ${username || '(auto-generate)'} on panel ${panel.name} (trial: ${isTrial})`);

        const result = await panel.createUser(username, password, packageData, bouquetIds, isTrial, notes);

        // Get actual username/password (could be auto-generated by panel)
        const actualUsername = result.username;
        const actualPassword = result.password;

        // Check if the panel already returned line_id (the key identifier for IPTV accounts)
        // If so, use it directly to avoid double querying - expiration may be null for trial users
        if (result.line_id) {
            console.log('âœ… Panel returned line_id - using panel data directly');
            console.log(`ðŸ“ Panel returned: line_id=${result.line_id}, expiration=${result.expiration}, connections=${result.connections}`);
            return {
                ...result,
                m3u_url: panel.generateM3UPlusURL(actualUsername, actualPassword),
                stream_urls: panel.generateStreamURLs(actualUsername, actualPassword),
                implayer_code: panel.generateiMPlayerCode(actualUsername, actualPassword)
            };
        }

        // Wait for user to be indexed on panel (only if not already done by panel)
        if (!result.auto_generated) {
            console.log('â³ Waiting 5 seconds for user to be indexed...');
            await new Promise(resolve => setTimeout(resolve, 5000));
        }

        // Fetch full user data using actual username
        const fullUserData = await panel.findUserByUsername(actualUsername);

        if (!fullUserData) {
            console.warn(`âš ï¸ User ${actualUsername} created but not found in panel data yet`);
            // Use values from panel's createUser response as fallback (e.g., OneStreamPanel returns these)
            console.log(`ðŸ“ Using panel create response data: line_id=${result.line_id}, expiration=${result.expiration}, connections=${result.connections}`);
            return {
                ...result,
                username: actualUsername,
                password: actualPassword,
                line_id: result.line_id || null,
                expiration: result.expiration || null,
                connections: result.connections || null,
                m3u_url: panel.generateM3UPlusURL(actualUsername, actualPassword),
                stream_urls: panel.generateStreamURLs(actualUsername, actualPassword),
                implayer_code: panel.generateiMPlayerCode(actualUsername, actualPassword)
            };
        }

        return {
            ...result,
            username: actualUsername,
            password: actualPassword,
            line_id: fullUserData.id,
            expiration: fullUserData.exp_date,
            connections: fullUserData.user_connection || fullUserData.connections,
            m3u_url: panel.generateM3UPlusURL(actualUsername, actualPassword),
            stream_urls: panel.generateStreamURLs(actualUsername, actualPassword),
            implayer_code: panel.generateiMPlayerCode(actualUsername, actualPassword),
            full_user_data: fullUserData
        };
    }

    /**
     * Extend user on specific panel
     * @param {number} panelId - Panel ID
     * @param {string} lineId - Line ID to extend
     * @param {object} packageData - Package data
     * @param {array} bouquetIds - Bouquet IDs (optional)
     * @param {string} bouquetSyncMode - Bouquet sync mode for 1-Stream panels (optional)
     */
    async extendUserOnPanel(panelId, lineId, packageData, bouquetIds, bouquetSyncMode = 'no_change') {
        const panel = this.getPanel(panelId);

        console.log(`ðŸ“¡ Extending user ${lineId} on panel ${panel.name}`);
        console.log(`ðŸ“¡ Bouquet sync mode: ${bouquetSyncMode}`);

        return await panel.extendUser(lineId, packageData, bouquetIds, bouquetSyncMode);
    }

    /**
     * Delete user from specific panel
     */
    async deleteUserFromPanel(panelId, lineId) {
        const panel = this.getPanel(panelId);

        console.log(`ðŸ“¡ Deleting user ${lineId} from panel ${panel.name}`);

        return await panel.deleteUser(lineId);
    }

    /**
     * Get all users from specific panel
     */
    async getAllUsersFromPanel(panelId, limit = 10000, offset = 0) {
        const panel = this.getPanel(panelId);
        return await panel.getAllUsers(limit, offset);
    }

    /**
     * Find user by username on specific panel
     */
    async findUserOnPanel(panelId, username) {
        const panel = this.getPanel(panelId);
        return await panel.findUserByUsername(username);
    }

    /**
     * Search for user by username across all panels (PARALLEL EXECUTION)
     */
    async searchUserAcrossAllPanels(username) {
        console.log(`ðŸ” Searching for username "${username}" across all panels in parallel...`);

        // Process all panels in parallel using Promise.all
        const searchResults = await Promise.all(
            Array.from(this.panels.entries()).map(async ([panelId, panel]) => {
                try {
                    const userData = await panel.findUserByUsername(username);

                    if (userData) {
                        console.log(`âœ… Found user "${username}" on panel ${panel.name}`);
                        return {
                            panel_id: panelId,
                            panel_name: panel.name,
                            panel_type: panel.panelType,
                            found: true,
                            user_data: userData
                        };
                    } else {
                        console.log(`âŒ User "${username}" not found on panel ${panel.name}`);
                        return {
                            panel_id: panelId,
                            panel_name: panel.name,
                            panel_type: panel.panelType,
                            found: false,
                            user_data: null
                        };
                    }
                } catch (error) {
                    console.error(`âŒ Error searching panel ${panel.name}:`, error.message);
                    return {
                        panel_id: panelId,
                        panel_name: panel.name,
                        panel_type: panel.panelType,
                        found: false,
                        user_data: null,
                        error: error.message
                    };
                }
            })
        );

        // Filter to only panels where user was found
        const foundOnPanels = searchResults.filter(result => result.found);

        return {
            username,
            found: foundOnPanels.length > 0,
            total_panels_searched: searchResults.length,
            found_on_panel_count: foundOnPanels.length,
            results: foundOnPanels,
            all_results: searchResults
        };
    }

    /**
     * Sync packages for specific panel
     */
    async syncPanelPackages(panelId) {
        const panel = this.getPanel(panelId);

        console.log(`ðŸ”„ Syncing packages for panel ${panel.name}...`);

        return await panel.syncPackages();
    }

    /**
     * Sync packages for all panels (PARALLEL EXECUTION)
     */
    async syncAllPanelPackages() {
        console.log('ðŸ”„ Syncing packages for all panels in parallel...');

        // Process all panels in parallel using Promise.all
        const results = await Promise.all(
            Array.from(this.panels.entries()).map(async ([panelId, panel]) => {
                try {
                    const packages = await panel.syncPackages();
                    return {
                        panel_id: panelId,
                        panel_name: panel.name,
                        package_count: packages.length,
                        success: true
                    };
                } catch (error) {
                    console.error(`âŒ Failed to sync packages for ${panel.name}:`, error.message);
                    return {
                        panel_id: panelId,
                        panel_name: panel.name,
                        success: false,
                        error: error.message
                    };
                }
            })
        );

        return results;
    }

    /**
     * Sync bouquets for specific panel
     */
    async syncPanelBouquets(panelId) {
        const panel = this.getPanel(panelId);

        console.log(`ðŸ”„ Syncing bouquets for panel ${panel.name}...`);

        return await panel.syncBouquets();
    }

    /**
     * Sync bouquets for all panels (PARALLEL EXECUTION)
     */
    async syncAllPanelBouquets() {
        console.log('ðŸ”„ Syncing bouquets for all panels in parallel...');

        // Process all panels in parallel using Promise.all
        const results = await Promise.all(
            Array.from(this.panels.entries()).map(async ([panelId, panel]) => {
                try {
                    const bouquets = await panel.syncBouquets();
                    return {
                        panel_id: panelId,
                        panel_name: panel.name,
                        bouquet_count: bouquets.length,
                        success: true
                    };
                } catch (error) {
                    console.error(`âŒ Failed to sync bouquets for ${panel.name}:`, error.message);
                    return {
                        panel_id: panelId,
                        panel_name: panel.name,
                        success: false,
                        error: error.message
                    };
                }
            })
        );

        return results;
    }

    /**
     * Get credit balance for specific panel
     */
    async getPanelCreditBalance(panelId) {
        const panel = this.getPanel(panelId);
        return await panel.getCreditBalance();
    }

    /**
     * Get available extension/renewal packages for a user on a panel
     * Only NXTDash panels support this
     */
    async getExtensionPackages(panelId, lineId) {
        const panel = this.getPanel(panelId);

        // Check if the panel supports getExtensionPackages
        if (typeof panel.getExtensionPackages !== 'function') {
            throw new Error(`Panel type ${panel.constructor.name} does not support fetching extension packages`);
        }

        return await panel.getExtensionPackages(lineId);
    }

    /**
     * Get credit balances for all panels (PARALLEL EXECUTION)
     */
    async getAllPanelCreditBalances() {
        // Process all panels in parallel using Promise.all
        const balances = await Promise.all(
            Array.from(this.panels.entries()).map(async ([panelId, panel]) => {
                try {
                    const credits = await panel.getCreditBalance();
                    return {
                        panel_id: panelId,
                        panel_name: panel.name,
                        credits,
                        success: true
                    };
                } catch (error) {
                    console.error(`âŒ Failed to get credits for ${panel.name}:`, error.message);
                    return {
                        panel_id: panelId,
                        panel_name: panel.name,
                        credits: 0,
                        success: false,
                        error: error.message
                    };
                }
            })
        );

        return balances;
    }

    /**
     * Get active streams from all panels (PARALLEL EXECUTION)
     */
    async getAllActiveStreams() {
        console.log('ðŸ“Š Fetching active streams from all panels in parallel...');

        // Process all panels in parallel using Promise.all
        const allStreams = await Promise.all(
            Array.from(this.panels.entries()).map(async ([panelId, panel]) => {
                try {
                    const streams = await panel.getActiveStreams();
                    return {
                        panel_id: panelId,
                        panel_name: panel.name,
                        panel_type: panel.panelType,
                        streams
                    };
                } catch (error) {
                    console.error(`âŒ Failed to get streams from ${panel.name}:`, error.message);
                    return {
                        panel_id: panelId,
                        panel_name: panel.name,
                        panel_type: panel.panelType,
                        streams: [],
                        error: error.message
                    };
                }
            })
        );

        return allStreams;
    }

    /**
     * Test connection for specific panel
     */
    async testPanelConnection(panelId) {
        const panel = this.getPanel(panelId);

        console.log(`ðŸ” Testing connection to panel ${panel.name}...`);

        try {
            const isOnline = await panel.testConnection();
            return {
                panel_id: panelId,
                panel_name: panel.name,
                online: isOnline,
                message: isOnline ? 'Connection successful' : 'Connection failed'
            };
        } catch (error) {
            return {
                panel_id: panelId,
                panel_name: panel.name,
                online: false,
                message: error.message
            };
        }
    }

    /**
     * Test connection for all panels (PARALLEL EXECUTION)
     */
    async testAllPanelConnections() {
        console.log('ðŸ” Testing connections to all panels in parallel...');

        // Process all panels in parallel using Promise.all
        const results = await Promise.all(
            Array.from(this.panels.keys()).map(async (panelId) => {
                return await this.testPanelConnection(panelId);
            })
        );

        return results;
    }

    /**
     * Get aggregated stats from all panels (PARALLEL EXECUTION)
     */
    async getAggregatedStats() {
        const stats = {
            total_panels: this.panels.size,
            online_panels: 0,
            total_credits: 0,
            panels: []
        };

        // Process all panels in parallel using Promise.all
        const panelResults = await Promise.all(
            Array.from(this.panels.entries()).map(async ([panelId, panel]) => {
                try {
                    // Test if panel is online
                    const isOnline = await panel.testConnection();

                    // Try to get credit balance
                    let credits = 0;
                    try {
                        credits = await panel.getCreditBalance();
                    } catch (error) {
                        // Credit balance not available
                    }

                    return {
                        id: panelId,
                        name: panel.name,
                        type: panel.panelType,
                        online: isOnline,
                        credits,
                        health_status: isOnline ? 'online' : 'offline'
                    };

                } catch (error) {
                    console.error(`âŒ Failed to get stats for ${panel.name}:`, error.message);
                    return {
                        id: panelId,
                        name: panel.name,
                        type: panel.panelType,
                        online: false,
                        credits: 0,
                        health_status: 'error',
                        error: error.message
                    };
                }
            })
        );

        // Aggregate results
        panelResults.forEach(panelStat => {
            if (panelStat.online) {
                stats.online_panels++;
            }
            stats.total_credits += panelStat.credits || 0;
            stats.panels.push(panelStat);
        });

        return stats;
    }

    /**
     * Reload panels from database (call this after adding/editing panels)
     */
    async reload() {
        console.log('ðŸ”„ Reloading IPTV panels from database...');
        await this.loadPanels();
    }

    /**
     * Get user info from panel by line ID
     * Used to sync/refresh user data from panel (connections, expiration, etc.)
     */
    async getUserInfoOnPanel(panelId, lineId) {
        const panel = this.getPanel(panelId);

        // Check if the panel supports getUserInfo
        if (typeof panel.getUserInfo !== 'function') {
            throw new Error(`Panel type ${panel.constructor.name} does not support getUserInfo`);
        }

        console.log(`ðŸ”„ Syncing user info for line_id ${lineId} from panel ${panel.name}...`);
        return await panel.getUserInfo(lineId);
    }
}

module.exports = IPTVServiceManager;
